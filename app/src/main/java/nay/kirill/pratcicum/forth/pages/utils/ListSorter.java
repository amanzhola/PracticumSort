package nay.kirill.pratcicum.forth.pages.utils;

import java.util.Collections;
import java.util.List;
import nay.kirill.pratcicum.forth.pages.ComparableItem;

public class ListSorter {

    /*
    public void sort(List list) {
        // TODO (3) добавить сортировку элементов
    }

     */
    public void sort(List<? extends ComparableItem> list) {
        list.sort((o1, o2) -> o1.compare(o2));
    }

}
/*
Использование Wildcard: Метод sort принимает список, содержащий элементы,
которые являются подтипами ComparableItem.
Это позволяет использовать преимущества полиморфизма и гарантирует,
что все элементы списка могут быть сравнены, так как они реализуют интерфейс ComparableItem.
Сортировка через встроенный метод: В методе используется метод sort интерфейса List,
чтобы отсортировать элементы списка. Передается лямбда-выражение,
которое использует метод compare для сравнения пар элементов.
Неявное требование реализации интерфейса: Этот подход делает требование реализации
ComparableItem на уровне метода, а не на уровне объекта,
тем самым улучшая читаемость и гибкость кода.

compare:
Обобщенный метод: Метод sort является обобщенным (<T>),
что позволяет ему работать с любым типом объекта.
Это дает больше гибкости, поскольку метод может сортировать любой список,
передавая соответствующий компаратор.
Использование Comparator: Метод требует, чтобы Caller предоставил Comparator,
который определяет порядок сортировки.
Это делает сортировку более настраиваемой и позволяет использовать
различные стратегии сравнения для разных типов объектов.
Стандартная библиотека: В примере используется Collections.sort,
что позволяет воспользоваться проверенным методом сортировки, встроенным в Java.
 */